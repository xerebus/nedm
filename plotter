#!/usr/bin/env python

# plotter.py (Aritra Biswas)
# --------------------------
# Generates {Bx, By, Bz} vs {x, y, z} plots from rotationshield output

import numpy as np
import matplotlib.pyplot as plt
import sys
import os.path

from matplotlib.font_manager import FontProperties

def parse_file(ipath):
    '''Decide whether the given path is a folder containing rotationshield
    output or a file containing FieldMapping VI output, and parse the file
    accordingly.'''

    is_rotshield = True

    print "[path] === Examining %s" % ipath

    try:
        f = open(ipath + "/Fieldmap.txt", 'r')
        print "[path] Found Fieldmap.txt."
    except IOError:
        print "[path] Did not find Fieldmap.txt. Trying as text file."
        is_rotshield = False
        try:
            f = open(ipath, 'r')
        except IOError:
            raise ValueError("%s does not contain rotationshield output, \
            nor is it a text file. Cannot handle." % ipath)

    if is_rotshield:
        return parse_sim_file(f)
    else:
        # must be a VI file, because if not, plotter will exit with ValueError
        # above
        return parse_meas_file(f)

def parse_sim_file(f):
    '''Parse a rotationshield file object. Return (x, y, z, Bx, By, Bz)
    arrays.'''

    print "[file] Reading as rotationshield output..."
     
    x = np.array([])
    y = np.array([])
    z = np.array([])
    Bx = np.array([])
    By = np.array([])
    Bz = np.array([])

    for line in f:
        
        try:
            (this_x, this_y, this_z, this_Bx, this_By, this_Bz) = line.split()
        except ValueError:
            raise ValueError("Cannot unpack line:\n%s" % line)

        x = np.append(x, np.float64(this_x))
        y = np.append(y, np.float64(this_y))
        z = np.append(z, np.float64(this_z))
        Bx = np.append(Bx, np.float64(this_Bx))
        By = np.append(By, np.float64(this_By))
        Bz = np.append(Bz, np.float64(this_Bz))
    
    f.close()

    print "[file] Reading done."

    return (x, y, z, Bx, By, Bz)

def parse_meas_file(f):
    '''Parse a VI measurement file object. Return (x, y, z, Bx, By, Bz)
    arrays.'''

    print "[file] Reading as VI output..."
    
    x = np.array([])
    y = np.array([])
    z = np.array([])
    Bx = np.array([])
    By = np.array([])
    Bz = np.array([])

    # FieldMapping VI output files have a header that needs to be skipped
    header = f.readline()

    for line in f:

        try:
            # all variables not starting with this_ are thrown away
            (month, day, year, hour, minute, sec, timestamp, this_x, this_y, 
            this_z, current, current_err, oneax, oneax_err, this_Bx, Bx_err,
            this_By, By_err, this_Bz, Bz_err) = line.split()
        except ValueError:
            raise ValueError("Cannot unpack line:\n%s" % line)
        
        x = np.append(x, np.float64(this_x))
        y = np.append(y, np.float64(this_y))
        z = np.append(z, np.float64(this_z))
        Bx = np.append(Bx, np.float64(this_Bx))
        By = np.append(By, np.float64(this_By))
        Bz = np.append(Bz, np.float64(this_Bz))
    
    f.close()

    # FieldMapping VI outputs distances in mm, we want meters
    print "[file] Converting distances..."
    x /= np.float64(1000)
    y /= np.float64(1000)
    z /= np.float64(1000)

    print "[file] Reading done."

    return (x, y, z, Bx, By, Bz)

def usage():
    '''Print usage message.'''
    
    print "%s [-x] [-y] [-z] [-Bx] [-By] [-Bz] path1 [path2] ..." % sys.argv[0]
    print " * For rotationshield output, the path should be a folder name with"
    print "   a trailing slash."
    print " * For FieldMapping VI output, the path should be the text file."
    print " * Option flags must precede the list of paths."

if __name__ == '__main__':

    # handle input flags

    first_arg = 1
    
    no_flags = True
    horiz = 0
    vert = 0

    x_show = False
    y_show = False
    z_show = False
    Bx_show = False
    By_show = False
    Bz_show = False

    for arg in sys.argv:
        if arg == "-x":
            x_show = True
            horiz += 1
            first_arg +=1
        elif arg == "-y":
            y_show = True
            horiz += 1
            first_arg += 1
        elif arg == "-z":
            z_show = True
            horiz += 1
            first_arg += 1
        elif arg == "-Bx":
            Bx_show = True
            vert += 1
            first_arg += 1
        elif arg == "-By":
            By_show = True
            vert += 1
            first_arg += 1
        elif arg == "-Bz":
            Bz_show = True
            vert += 1
            first_arg += 1
        elif arg == "help":
            usage()
            exit()

    if x_show == False and y_show == False and z_show == False:
        x_show = True
        y_show = True
        z_show = True
    if Bx_show == False and By_show == False and Bz_show == False:
        Bx_show = True
        By_show = True
        Bz_show = True

    if horiz == 0:
        horiz = 3
    if vert == 0:
        vert = 3

    fig = plt.figure()

    i = 1 # subplot counter
   
    if Bx_show == True and x_show == True:
        Bx_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bx")
        i += 1
    if Bx_show == True and y_show == True:
        Bx_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bx")
        i += 1
    if Bx_show == True and z_show == True:
        Bx_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bx")
        i += 1
    if By_show == True and x_show == True:
        By_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "By")
        i += 1
    if By_show == True and y_show == True:
        By_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "By")
        i += 1
    if By_show == True and z_show == True:
        By_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "By")
        i += 1
    if Bz_show == True and x_show == True:
        Bz_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bz")
        i += 1
    if Bz_show == True and y_show == True:
        Bz_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bz")
        i += 1
    if Bz_show == True and z_show == True:
        Bz_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bz")

    print "[plot] === %i plots requested." % i

    j = 0 # line counter
    marker = ["o", "D", "s", "^", "<", ">", "v", "h"]
    
    for i in range(first_arg, len(sys.argv)):
        print "[plot] Plotting curve %i..." % (j + 1)
        (x, y, z, Bx, By, Bz) = parse_file(sys.argv[i])
        plotlabel = os.path.basename(os.path.normpath(sys.argv[i]))
        if Bx_show == True and x_show == True:
            Bx_v_x.plot(x, Bx, marker[j], label = plotlabel)
        if Bx_show == True and y_show == True:
            Bx_v_y.plot(y, Bx, marker[j], label = plotlabel) 
        if Bx_show == True and z_show == True:
            Bx_v_z.plot(z, Bx, marker[j], label = plotlabel)
        if By_show == True and x_show == True:
            By_v_x.plot(x, By, marker[j], label = plotlabel)
        if By_show == True and y_show == True:
            By_v_y.plot(y, By, marker[j], label = plotlabel)
        if By_show == True and z_show == True:
            By_v_z.plot(z, By, marker[j], label = plotlabel)
        if Bz_show == True and x_show == True:
            Bz_v_x.plot(x, Bz, marker[j], label = plotlabel)
        if Bz_show == True and y_show == True:
            Bz_v_y.plot(y, Bz, marker[j], label = plotlabel)
        if Bz_show == True and z_show == True:
            Bz_v_z.plot(z, Bz, marker[j], label = plotlabel)
        j += 1

    fontp = FontProperties()
    fontp.set_size("small")
    
    plt.legend(loc = 2, prop = fontp)

    print "[plot] === Plotting done."
    plt.show()
