#!/usr/bin/env python

# plotter.py (Aritra Biswas)
# --------------------------
# Generates {Bx, By, Bz} vs {x, y, z} plots from rotationshield output

import numpy as np
import matplotlib.pyplot as plt
import sys
import os.path
import optparse
import math

from matplotlib.font_manager import FontProperties

def find_indices(array_condition):
    '''Given a 1D numpy array, finds indices where the value in the array
    meets the condition. Condition should be written in terms of array, not
    array[i].'''

    return list(np.nonzero(array_condition)[0])

class Field:
    '''Store a vector field that can be generated from rotationshield or VI
    output.'''

    def __init__(self, ipath):
        '''Decide whether the given path is a folder containing rotationshield
        output or a file containing FieldMapping VI output, and parse the file
        accordingly.'''
        
        self.x = np.array([])
        self.y = np.array([])
        self.z = np.array([])
        self.Bx = np.array([])
        self.By = np.array([])
        self.Bz = np.array([])
        
        self.is_simmap = True

        self.avg_Bx = 0

        self.path = ipath
        self.label = os.path.basename(os.path.normpath(ipath))
        
        print "[path] === Examining %s" % ipath

        try:
            f = open(ipath + "/Fieldmap.txt", 'r')
            print "[path] Found Fieldmap.txt."
        except IOError:
            print "[path] Did not find Fieldmap.txt. Trying as text file."
            self.is_simmap = False
            try:
                f = open(ipath, 'r')
            except IOError:
                raise ValueError("%s does not contain rotationshield output, \
                nor is it a text file. Cannot handle." % ipath)

        if self.is_simmap:
            print "[path] Reading as rotationshield output..."
            self.read_sim_file(f)
        else:
            # must be a VI file, because if not, plotter will exit with
            # ValueError above
            print "[path] Reading as VI output..."
            self.read_meas_file(f)


    def read_sim_file(self, f):
        '''Parse a rotationshield file object.'''

        print "[file] Parsing rotationshield output file..."

        for line in f:
            
            try:
                (this_x, this_y, this_z, this_Bx, this_By,
                this_Bz) = line.split()
            except ValueError:
                raise ValueError("Cannot unpack line:\n%s" % line)

            self.x = np.append(self.x, np.float64(this_x))
            self.y = np.append(self.y, np.float64(this_y))
            self.z = np.append(self.z, np.float64(this_z))
            self.Bx = np.append(self.Bx, np.float64(this_Bx))
            self.By = np.append(self.By, np.float64(this_By))
            self.Bz = np.append(self.Bz, np.float64(this_Bz))

        f.close()

        print "[file] Reading done."


    def read_meas_file(self, f):
        '''Parse a VI measurement file object.'''

        print "[file] Parsing VI output file..."
        
        # FieldMapping VI output files have a header that needs to be skipped
        header = f.readline()

        for line in f:

            try:
                # all variables not starting with this_ are thrown away
                (month, day, year, hour, minute, sec, timestamp, this_x,
                this_y, this_z, current, current_err, oneax, oneax_err,
                this_Bx, Bx_err, this_By, By_err, this_Bz,
                Bz_err) = line.split()
            except ValueError:
                raise ValueError("Cannot unpack line:\n%s" % line)
            
            self.x = np.append(self.x, np.float64(this_x))
            self.y = np.append(self.y, np.float64(this_y))
            self.z = np.append(self.z, np.float64(this_z))
            self.Bx = np.append(self.Bx, np.float64(this_Bx))
            self.By = np.append(self.By, np.float64(this_By))
            self.Bz = np.append(self.Bz, np.float64(this_Bz))
        
        f.close()

        # FieldMapping VI outputs distances in mm, we want meters
        print "[file] Converting distances..."
        self.x /= np.float64(1000)
        self.y /= np.float64(1000)
        self.z /= np.float64(1000)

        print "[file] Reading done."

    def calc_avg_Bx(self):
        '''Calculate the average Bx around the center from existing data.'''

        center_box_size = 0.01
        
        print "[calc] Finding data points around center..."

        x_small = find_indices(np.abs(self.x) <= center_box_size)
        y_small = find_indices(np.abs(self.y) <= center_box_size)
        z_small = find_indices(np.abs(self.z) <= center_box_size)
        close_to_center = np.intersect1d(x_small, y_small, z_small)
        print "[calc] Taking samples from %i points." % len(close_to_center)

        Bx_sample = np.array([])
        for index in close_to_center:
            Bx_sample = np.append(Bx_sample, self.Bx[index])

        self.avg_Bx = np.average(Bx_sample)
        print "[calc] Calculated average Bx as %f mG." % self.avg_Bx

    def normalize(self, newnorm):
        '''Given 'newnorm', the desired average field in the middle, scale a
        simulated field.'''

        assert self.is_simmap, ("Why are you trying to normalize a measured " +
        "field?")

        self.calc_avg_Bx()
        scale = newnorm / self.avg_Bx

        self.Bx *= scale
        self.By *= scale
        self.Bz *= scale

    def subtract_bg(self, bgfield):
        '''Given another Field object representing a background field,
        subtract that field from this one.'''

        assert not self.is_simmap, ("Why are you subtracting background " +
        "data from a simulated field?")
        
        try:
            self.Bx -= bgfield.Bx
            self.By -= bgfield.By
            self.Bz -= bgfield.Bz
        except ValueError:
            raise ValueError("Make sure your background field is taken " +
            "with the same gridding as all of your foreground fields.")

    def slice(self, x, y, z):
        '''Given specific x, y, z values, restrict the field to points close
        to those values.'''

        tol = 0.01 # tolerance in m

        if not math.isnan(x):
            elim_x = find_indices(np.abs(self.x - x) > tol)
        else:
            elim_x = []
        if not math.isnan(y):
            elim_y = find_indices(np.abs(self.y - y) > tol)
        else:
            elim_y = []
        if not math.isnan(z):
            elim_z = find_indices(np.abs(self.z - z) > tol)
        else:
            elim_z = []
        
        elim_indices = elim_x + elim_y + elim_z
        print "[slcf] Eliminating %i points outside slice." % len(elim_indices)

        self.x = np.delete(self.x, elim_indices)
        self.y = np.delete(self.y, elim_indices)
        self.z = np.delete(self.z, elim_indices)
        self.Bx = np.delete(self.Bx, elim_indices)
        self.By = np.delete(self.By, elim_indices)
        self.Bz = np.delete(self.Bz, elim_indices)


if __name__ == "__main__":

    # handle input flags
    parser = optparse.OptionParser()
    parser.add_option("-i", "--showx", action = "store_true", dest = "x_show",
    help = "Show x plots", default = False)
    parser.add_option("-j", "--showy", action = "store_true", dest = "y_show",
    help = "Show y plots", default = False)
    parser.add_option("-k", "--showz", action = "store_true", dest = "z_show",
    help = "Show z plots", default = False)
    parser.add_option("-X", "--showBx", action = "store_true", dest = "Bx_show",
    help = "Show Bx plots", default = False)
    parser.add_option("-Y", "--showBy", action = "store_true", dest = "By_show",
    help = "Show By plots", default = False)
    parser.add_option("-Z", "--showBz", action = "store_true", dest = "Bz_show",
    help = "Show Bz plots", default = False)

    parser.add_option("-b", "--background", action = "store", dest = "bgpath",
    help = ("Specify a path to a VI-output text file containing background " +
    " data. This data will be subtracted from all other VI-output data."),
    default = None)
    
    parser.add_option("-n", "--normal", action = "store", dest = "newnorm",
    help = "Custom normalization level in mG.", default = None)

    parser.add_option("-x", "--slicex", action = "store", dest = "sx",
    help = "Restrict to points near x = SX.", default = None)
    parser.add_option("-y", "--slicey", action = "store", dest = "sy",
    help = "Restrict to points near y = SY.", default = None)
    parser.add_option("-z", "--slicez", action = "store", dest = "sz",
    help = "Restrict to points near z = SZ.", default = None)
    
    parser.usage = ("%s [options] path1 [path2] ...\n" +
    "The path should be either a text file containing Labview VI output\n" +
    "or a folder containing a Fieldmap.txt created with rotationshield.\n" +
    "The program will automatically determine which type is being read.\n")
        
    (opts, args) = parser.parse_args()

    # if all plots are disabled, then show them all
    if not opts.x_show and not opts.y_show and not opts.z_show:
        opts.x_show = True
        opts.y_show = True
        opts.z_show = True
    if not opts.Bx_show and not opts.By_show and not opts.Bz_show:
        opts.Bx_show = True
        opts.By_show = True
        opts.Bz_show = True


    # count how many horizontal & vertical axes there will be
    horiz = 0
    vert = 0
    for opt in [opts.x_show, opts.y_show, opts.z_show]:
        if opt:
            horiz += 1
    for opt in [opts.Bx_show, opts.By_show, opts.Bz_show]:
        if opt:
            vert += 1
    if horiz == 0:
        horiz = 3
    if vert == 0:
        vert = 3

    # create the correct number of subplots
    
    fig = plt.figure()
    i = 1 # subplot counter

    if opts.Bx_show == True and opts.x_show == True:
        Bx_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bx")
        i += 1
    if opts.Bx_show == True and opts.y_show == True:
        Bx_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bx")
        i += 1
    if opts.Bx_show == True and opts.z_show == True:
        Bx_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bx")
        i += 1
    if opts.By_show == True and opts.x_show == True:
        By_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "By")
        i += 1
    if opts.By_show == True and opts.y_show == True:
        By_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "By")
        i += 1
    if opts.By_show == True and opts.z_show == True:
        By_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "By")
        i += 1
    if opts.Bz_show == True and opts.x_show == True:
        Bz_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bz")
        i += 1
    if opts.Bz_show == True and opts.y_show == True:
        Bz_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bz")
        i += 1
    if opts.Bz_show == True and opts.z_show == True:
        Bz_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bz")

    print "[plot] === %i plots will be made." % i

    # populate a list of Field objects
    fields = []
    for ipath in args:
        fields.append(Field(ipath))

    # subtract background data from all measured maps
    if opts.bgpath is not None:
        print "[fgbg] Found background file. Subtracting..."
        bgfield = Field(opts.bgpath)
        for field in fields:
            if not field.is_simmap:
                field.subtract_bg(bgfield)
        print "[fgbg] Background removed."

    # normalize all simulation maps
    if opts.newnorm is not None:
        newnorm = np.float64(opts.newnorm)
        print "[norm] Using provided normalization level of %f mG." % newnorm
    else:
        print "[norm] Calculating normalization level..."
        norms = np.array([])
        for field in fields:
            if not field.is_simmap:
                field.calc_avg_Bx()
                norms = np.append(norms, np.float64(field.avg_Bx))
        if norms.size == 0:
            newnorm = 30
            print "[norm] No measured maps found. Using %f mG." % newnorm
        else:
            newnorm = np.average(norms)
            print "[norm] Using calculated normalization level of %f mG." % newnorm
    print "[norm] Checking for simulated fields to normalize..."
    for field in fields:
        if field.is_simmap:
            print "[norm] Normalizing %s..." % field.label
            field.normalize(newnorm)
    print "[norm] All simulated fields normalized to %f mG." % newnorm

    # slice fields
    print "[slcf] Checking for slicing needs..."
    for field in fields:
        field.slice(np.float64(opts.sx), np.float64(opts.sy), np.float64(opts.sz))
    print "[slcf] Slicing done."
    
    # plot curve for each field

    j = 0 # curve counter
    marker = ["o", "D", "s", "^", "<", ">", "v", "h"]
    
    for field in fields:
        print "[plot] Plotting curve (%i) %s..." % ((j + 1), field.label)
        if opts.Bx_show and opts.x_show:
            Bx_v_x.plot(field.x, field.Bx, marker[j], label = field.label)
        if opts.Bx_show and opts.y_show:
            Bx_v_y.plot(field.y, field.Bx, marker[j], label = field.label)
        if opts.Bx_show and opts.z_show:
            Bx_v_z.plot(field.z, field.Bx, marker[j], label = field.label)
        if opts.By_show and opts.x_show:
            By_v_x.plot(field.x, field.By, marker[j], label = field.label)
        if opts.By_show and opts.y_show:
            By_v_y.plot(field.y, field.By, marker[j], label = field.label)
        if opts.By_show and opts.z_show:
            By_v_z.plot(field.z, field.By, marker[j], label = field.label)
        if opts.Bz_show and opts.x_show:
            Bz_v_x.plot(field.x, field.Bz, marker[j], label = field.label)
        if opts.Bz_show and opts.y_show:
            Bz_v_y.plot(field.y, field.Bz, marker[j], label = field.label)
        if opts.Bz_show and opts.z_show:
            Bz_v_z.plot(field.z, field.Bz, marker[j], label = field.label)
        j += 1

    fontp = FontProperties()
    fontp.set_size("small")
    
    plt.legend(loc = 2, prop = fontp)

    print "[plot] === Plotting done."
    plt.show()
