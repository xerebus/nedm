#!/usr/bin/env python

# plotter.py (Aritra Biswas)
# --------------------------
# Generates {Bx, By, Bz} vs {x, y, z} plots from rotationshield output

# CONSTANTS
NEWNORM = 540.0 # field in middle of experimental setup [mG]
# TODO: determine this programatically by calculating average of measured
# field input, see other TODO below

import numpy as np
import matplotlib.pyplot as plt
import sys
import os.path
import optparse

from matplotlib.font_manager import FontProperties

# ugly hack to import rotationshield script through a symlink without
# actually copying the script into this repo
sys.path.append("rotationshield/Scripts/")
from StudyPlotter import *
# TODO: calculate the average without rotationshield, directly from the
# text file; calculate the average for measured maps to get NEWNORM

class Field:
    '''Store a vector field that can be generated from rotationshield or VI
    output.'''

    def __init__(self, ipath):
        '''Decide whether the given path is a folder containing rotationshield
        output or a file containing FieldMapping VI output, and parse the file
        accordingly.'''
        
        self.x = np.array([])
        self.y = np.array([])
        self.z = np.array([])
        self.Bx = np.array([])
        self.By = np.array([])
        self.Bz = np.array([])
        
        self.is_simmap = True

        self.avg_Bx = 0

        self.path = ipath
        self.label = os.path.basename(os.path.normpath(ipath))
        
        print "[path] === Examining %s" % ipath

        try:
            f = open(ipath + "/Fieldmap.txt", 'r')
            print "[path] Found Fieldmap.txt."
        except IOError:
            print "[path] Did not find Fieldmap.txt. Trying as text file."
            self.is_simmap = False
            try:
                f = open(ipath, 'r')
            except IOError:
                raise ValueError("%s does not contain rotationshield output, \
                nor is it a text file. Cannot handle." % ipath)

        if self.is_simmap:
            print "[path] Reading as rotationshield output..."
            self.read_sim_file(f) # TODO
        else:
            # must be a VI file, because if not, plotter will exit with
            # ValueError above
            print "[path] Reading as VI output..."
            self.read_meas_file(f)


    def read_sim_file(self, f):
        '''Parse a rotationshield file object.'''

        print "[file] Opened rotationshield output file."

        for line in f:
            
            try:
                (this_x, this_y, this_z, this_Bx, this_By,
                this_Bz) = line.split()
            except ValueError:
                raise ValueError("Cannot unpack line:\n%s" % line)

            self.x = np.append(self.x, np.float64(this_x))
            self.y = np.append(self.y, np.float64(this_y))
            self.z = np.append(self.z, np.float64(this_z))
            self.Bx = np.append(self.Bx, np.float64(this_Bx))
            self.By = np.append(self.By, np.float64(this_By))
            self.Bz = np.append(self.Bz, np.float64(this_Bz))

        f.close()

        print "[file] Reading done."


    def read_meas_file(self, f):
        '''Parse a VI measurement file object.'''

        print "[file] Opened VI output file."
        
        # FieldMapping VI output files have a header that needs to be skipped
        header = f.readline()

        for line in f:

            try:
                # all variables not starting with this_ are thrown away
                (month, day, year, hour, minute, sec, timestamp, this_x,
                this_y, this_z, current, current_err, oneax, oneax_err,
                this_Bx, Bx_err, this_By, By_err, this_Bz,
                Bz_err) = line.split()
            except ValueError:
                raise ValueError("Cannot unpack line:\n%s" % line)
            
            self.x = np.append(self.x, np.float64(this_x))
            self.y = np.append(self.y, np.float64(this_y))
            self.z = np.append(self.z, np.float64(this_z))
            self.Bx = np.append(self.Bx, np.float64(this_Bx))
            self.By = np.append(self.By, np.float64(this_By))
            self.Bz = np.append(self.Bz, np.float64(this_Bz))
        
        f.close()

        # FieldMapping VI outputs distances in mm, we want meters
        print "[file] Converting distances..."
        self.x /= np.float64(1000)
        self.y /= np.float64(1000)
        self.z /= np.float64(1000)

        print "[file] Reading done."

    def calc_sim_avg_Bx(self):
        '''Find Fieldstats.txt and obtain the average B
        field that will be used to calculate the normalization factor.'''

        assert self.is_simmap, "Use Field.calc_meas_avg_Bx() instead."
        statpath = self.path + "/Fieldstats.txt"

        print "[calc] Finding additional rotationshield output..."

        try:
            f = open(statpath, 'r')
            print "[calc] Found Fieldstats.txt."
        except IOError:
            raise ValueError("%s appears to be missing Fieldstats.txt" % ipath)

        this_BC = BCell(statpath)
        # scaling factors
        this_BC.ll = (-0.01, -0.01, -0.01)
        this_BC.ur = (0.01, 0.01, 0.01)

        self.avg_Bx = this_BC.avgB()[0]
        print "[calc] Calculated average field."

    def normalize(self, newnorm):
        '''Given 'newnorm', the desired average field in the middle, scale a
        simulated field.'''

        assert self.is_simmap, ("Why are you trying to normalize a measured " +
        "field?")

        self.calc_sim_avg_Bx()
        scale = newnorm / self.avg_Bx

        self.Bx *= scale
        self.By *= scale
        self.Bz *= scale

    def subtract_bg(self, bgfield):
        '''Given another Field object representing a background field,
        subtract that field from this one.'''

        assert not self.is_simmap, ("Why are you subtracting background " +
        "data from a simulated field?")
        
        try:
            self.Bx -= bgfield.Bx
            self.By -= bgfield.By
            self.Bz -= bgfield.Bz
        except ValueError:
            raise ValueError("Make sure your background field is taken " +
            "with the same gridding as all of your foreground fields.")


if __name__ == "__main__":

    # handle input flags
    parser = optparse.OptionParser()
    parser.add_option("-x", action = "store_true", dest = "x_show",
    help = "Show x plots", default = False)
    parser.add_option("-y", action = "store_true", dest = "y_show",
    help = "Show y plots", default = False)
    parser.add_option("-z", action = "store_true", dest = "z_show",
    help = "Show z plots", default = False)
    parser.add_option("--Bx", action = "store_true", dest = "Bx_show",
    help = "Show Bx plots", default = False)
    parser.add_option("--By", action = "store_true", dest = "By_show",
    help = "Show By plots", default = False)
    parser.add_option("--Bz", action = "store_true", dest = "Bz_show",
    help = "Show Bz plots", default = False)

    parser.add_option("-b", action = "store", dest = "bgpath",
    help = ("Specify a path to a VI-output text file containing background " +
    " data. This data will be subtracted from all other VI-output data."),
    default = None)

    parser.usage = ("%s [options] path1 [path2] ...\n" +
    "The path should be either a text file containing Labview VI output\n" +
    "or a folder containing a Fieldmap.txt created with rotationshield.\n" +
    "The program will automatically determine which type is being read.\n")
        
    (opts, args) = parser.parse_args()

    # if all plots are disabled, then show them all
    if not opts.x_show and not opts.y_show and not opts.z_show:
        opts.x_show = True
        opts.y_show = True
        opts.z_show = True
    if not opts.Bx_show and not opts.By_show and not opts.Bz_show:
        opts.Bx_show = True
        opts.By_show = True
        opts.Bz_show = True


    # count how many horizontal & vertical axes there will be
    horiz = 0
    vert = 0
    for opt in [opts.x_show, opts.y_show, opts.z_show]:
        if opt:
            horiz += 1
    for opt in [opts.Bx_show, opts.By_show, opts.Bz_show]:
        if opt:
            vert += 1
    if horiz == 0:
        horiz = 3
    if vert == 0:
        vert = 3

    # create the correct number of subplots
    
    fig = plt.figure()
    i = 1 # subplot counter

    if opts.Bx_show == True and opts.x_show == True:
        Bx_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bx")
        i += 1
    if opts.Bx_show == True and opts.y_show == True:
        Bx_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bx")
        i += 1
    if opts.Bx_show == True and opts.z_show == True:
        Bx_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bx")
        i += 1
    if opts.By_show == True and opts.x_show == True:
        By_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "By")
        i += 1
    if opts.By_show == True and opts.y_show == True:
        By_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "By")
        i += 1
    if opts.By_show == True and opts.z_show == True:
        By_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "By")
        i += 1
    if opts.Bz_show == True and opts.x_show == True:
        Bz_v_x = fig.add_subplot(vert, horiz, i, xlabel = "x", ylabel = "Bz")
        i += 1
    if opts.Bz_show == True and opts.y_show == True:
        Bz_v_y = fig.add_subplot(vert, horiz, i, xlabel = "y", ylabel = "Bz")
        i += 1
    if opts.Bz_show == True and opts.z_show == True:
        Bz_v_z = fig.add_subplot(vert, horiz, i, xlabel = "z", ylabel = "Bz")

    print "[plot] === %i plots will be made." % i

    # populate a list of Field objects
    fields = []
    for ipath in args:
        fields.append(Field(ipath))

    # subtract background data from all measured maps
    if opts.bgpath is not None:
        print "[fgbg] Found background file. Subtracting..."
        bgfield = Field(opts.bgpath)
        for field in fields:
            if not field.is_simmap:
                field.subtract_bg(bgfield)
        print "[fgbg] Background removed."

    # normalize all simulation maps
    if NEWNORM is not None:
        print "[norm] Checking for simulated fields to normalize..."
        for field in fields:
            if field.is_simmap:
                print "[norm] Normalizing %s" % field.label
                field.normalize(NEWNORM)
        print "[norm] All simulated fields normalized."
    
    # plot curve for each field

    j = 0 # curve counter
    marker = ["o", "D", "s", "^", "<", ">", "v", "h"]
    
    for field in fields:
        print "[plot] Plotting curve %i..." % (j + 1)
        if opts.Bx_show and opts.x_show:
            Bx_v_x.plot(field.x, field.Bx, marker[j], label = field.label)
        if opts.Bx_show and opts.y_show:
            Bx_v_y.plot(field.y, field.Bx, marker[j], label = field.label)
        if opts.Bx_show and opts.z_show:
            Bx_v_z.plot(field.z, field.Bx, marker[j], label = field.label)
        if opts.By_show and opts.x_show:
            By_v_x.plot(field.x, field.By, marker[j], label = field.label)
        if opts.By_show and opts.y_show:
            By_v_y.plot(field.y, field.By, marker[j], label = field.label)
        if opts.By_show and opts.z_show:
            By_v_z.plot(field.z, field.By, marker[j], label = field.label)
        if opts.Bz_show and opts.x_show:
            Bz_v_x.plot(field.x, field.Bz, marker[j], label = field.label)
        if opts.Bz_show and opts.y_show:
            Bz_v_y.plot(field.y, field.Bz, marker[j], label = field.label)
        if opts.Bz_show and opts.z_show:
            Bz_v_z.plot(field.z, field.Bz, marker[j], label = field.label)
        j += 1

    fontp = FontProperties()
    fontp.set_size("small")
    
    plt.legend(loc = 2, prop = fontp)

    print "[plot] === Plotting done."
    plt.show()
